var documenterSearchIndex = {"docs":
[{"location":"#MatInt","page":"Home","title":"MatInt","text":"This  package  provides  the  Smith  and  Hermite normal forms for integral matrices,  the Diaconis-Graham  normal form  for sets  of generators  of an abelian  group,  and  a  few  functions to  work  with integral matrices as lattices.\n\nThe  Diaconis-Graham normal form is ported  from GAP3/Chevie. The rest of the  code is  ported from  GAP4/matint.g, authored  by A.  Storjohann, R. Wainwright,  F. Gähler and D. Holt; the code for NormalFormIntMat is still hard to read like the original one.\n\nThe best way to ensure the validity of the results is to work with matrices of  SaferIntegers, which error  on overflow. Then  repeat the computation with a wider type in case of an error.\n\nFor  the API, look at smith, smith_transforms, hermite, hermite_transforms, col_hermite, col_hermite_transforms, diaconis_graham, baseInt, complementInt, lnullspaceInt, solutionmatInt, intersect_rowspaceInt.\n\nWe  recall  that  a  unimodular  matrix  means an integer matrix which is invertible and whose inverse is still an integer matrix.\n\n\n\n\n\n","category":"module"},{"location":"#MatInt.hermite","page":"Home","title":"MatInt.hermite","text":"hermite(m::AbstractMatrix{<:Integer})\n\nreturns  the row Hermite normal  form H of m,  an upper triangular form with  the same  integral rowspace.  Furthermore, if  a pivot is the first non-zero  entry on a row of H, the  quadrant of H below and to the left of  a pivot is zero,  pivots are positive and  entries of H above a pivot are  nonnegative and less than the pivot.  There exists a (unique if m is of full rank) unimodular matrix r such that r*m==H.\n\njulia> m=[1 15 28;4 5 6;7 8 9]\n3×3 Matrix{Int64}:\n 1  15  28\n 4   5   6\n 7   8   9\n\njulia> hermite(m)\n3×3 Matrix{Int64}:\n 1  0  1\n 0  1  1\n 0  0  3\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.hermite_transforms","page":"Home","title":"MatInt.hermite_transforms","text":"hermite_transforms(m::AbstractMatrix{<:Integer})\n\nThe row Hermite normal form H of m is an upper triangular form with the same  integral rowspace.  Furthermore, if  a pivot  is the first non-zero entry on a row of H, the quadrant of H below and to the left of a pivot is  zero,  pivots  are  positive  and  entries  of  H  above  a pivot are nonnegative  and less than the  pivot. There exists a  (unique if m is of full   rank)  unimodular  matrix  r  such  that  r*m==H.  The  function hermite_transforms  returns a named tuple with components .normal=H and .rowtrans=r.\n\njulia> m=[1 15 28;4 5 6;7 8 9]\n3×3 Matrix{Int64}:\n 1  15  28\n 4   5   6\n 7   8   9\n\njulia> n=hermite_transforms(m)\n(normal = [1 0 1; 0 1 1; 0 0 3], rowtrans = [-2 62 -35; 1 -30 17; -3 97 -55], rank = 3, signdet = 1)\n\njulia> n.rowtrans*m==n.normal\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.col_hermite","page":"Home","title":"MatInt.col_hermite","text":"col_hermite(m::AbstractMatrix{<:Integer})\n\nreturns  the column Hermite  normal form H  of the integer  matrix m, a column equivalent lower triangular form. If a pivot is the first non-zero entry on a column of H (the quadrant above right a pivot is zero), pivots are  positive and entries left of a  pivot are nonnegative and smaller than the pivot. There exists a unique unimodular matrix c such that m*c==H.\n\njulia> m=[1 15 28;4 5 6;7 8 9]\n3×3 Matrix{Int64}:\n 1  15  28\n 4   5   6\n 7   8   9\n\njulia> col_hermite(m)\n3×3 Matrix{Int64}:\n 1  0  0\n 0  1  0\n 0  1  3\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.col_hermite_transforms","page":"Home","title":"MatInt.col_hermite_transforms","text":"col_hermite_transforms(m::AbstractMatrix{<:Integer})\n\nThe  column Hermite normal form  H of the integer  matrix m is a column equivalent  lower triangular form. If a pivot is the first non-zero entry on  a column of H (the quadrant above  right a pivot is zero), pivots are positive  and entries left of a pivot  are nonnegative and smaller than the pivot.  There exists a unique unimodular matrix c such that m*c==H. The function  col_hermite_transforms  returns  a  named tuple with components .normal=H and .coltrans=c.\n\njulia> m=[1 15 28;4 5 6;7 8 9]\n3×3 Matrix{Int64}:\n 1  15  28\n 4   5   6\n 7   8   9\n\njulia> n=col_hermite_transforms(m)\n(normal = [1 0 0; 0 1 0; 0 1 3], coltrans = [-1 13 -50; 2 -27 106; -1 14 -55], rank = 3, signdet = 1)\n\njulia> m*n.coltrans==n.normal\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.smith","page":"Home","title":"MatInt.smith","text":"smith(m::AbstractMatrix{<:Integer})\n\ncomputes  the Smith normal form  S of m, the  unique equivalent (in the sense  that there  exist unimodular  matrices r,  c such that r*m*c==S) diagonal matrix such that S[i,i] divides S[j,j] for i≤j.\n\njulia> m=[1 15 28 7;4 5 6 7;7 8 9 7]\n3×4 Matrix{Int64}:\n 1  15  28  7\n 4   5   6  7\n 7   8   9  7\n\njulia> smith(m)\n3×4 Matrix{Int64}:\n 1  0  0  0\n 0  1  0  0\n 0  0  3  0\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.smith_transforms","page":"Home","title":"MatInt.smith_transforms","text":"smith_transforms(m::AbstractMatrix{<:Integer})\n\nThe  Smith normal form of  m is the unique  equivalent (in the sense that there  exist  unimodular  matrices  r,  c  such that r*m*c==S) diagonal matrix  S such  that S[i,i]  divides S[j,j]  for i≤j.  The function smith_transforms  returns  a  named  tuple  with  components .normal=S, .rowtrans=r and .coltrans=c.\n\njulia> m=[1 15 28 7;4 5 6 7;7 8 9 7]\n3×4 Matrix{Int64}:\n 1  15  28  7\n 4   5   6  7\n 7   8   9  7\n\njulia> n=smith_transforms(m)\n(normal = [1 0 0 0; 0 1 0 0; 0 0 3 0], coltrans = [1 0 -1 -84; 0 1 -1 175; 0 0 1 -91; 0 0 0 1], rowtrans = [-2 62 -35; 1 -30 17; -3 97 -55], rank = 3, signdet = nothing)\n\njulia> n.rowtrans*m*n.coltrans==n.normal\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.diaconis_graham","page":"Home","title":"MatInt.diaconis_graham","text":"diaconis_graham(m::Matrix{<:Integer}, moduli::Vector{<:Integer})\n\nreturns the normal form defined for the set of generators defined by m of the  abelian group defined by moduli. in P. Diaconis and R. Graham., \"The graph  of generating sets  of an abelian  group\", Colloq. Math., 80:31–38, 1999.\n\nmoduli  should  have  positive  entries  such  that moduli[i+1] divides moduli[i] for all i, representing the abelian group A=ℤ/moduli[1]×…×ℤ/moduli[n], where n=length(moduli).\nm  should have n columns, and each  line, with the i-th element taken mod  moduli[i], represents  an element  of A;  the set  of rows  of m should generate A.\n\nThe  function returns  nothing if  the rows  of m  do not generate A. Otherwise it returns a named tuple r with fields\n\nr.normal:  the Diaconis-Graham normal form, a matrix of same shape as m where  either the first n rows are  the identity matrix and the remaining rows  are 0,  or length(m)=n  and .normal  differs from  the identity matrix only in the entry .normal[n,n], which is prime to moduli[n].\n\nr.rowtrans: unimodular matrix such that r.normal==mod.(r.rowtrans*m,moduli')\n\nHere is an example:\n\njulia> r=diaconis_graham([3 0;4 1],[10,5])\n(rowtrans = [-13 10; 4 -3], normal = [1 0; 0 2])\n\njulia> r.normal==mod.(r.rowtrans*[3 0;4 1],[10,5]')\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.baseInt","page":"Home","title":"MatInt.baseInt","text":"baseInt(m::Matrix{<:Integer})\n\nreturns  a matrix in  Hermite normal form  whose rows forms  a basis of the integral  row space of m, i.e. of the set of integral linear combinations of the rows of m.\n\njulia> m=[1 2 7;4 5 6;10 11 19]\n3×3 Matrix{Int64}:\n  1   2   7\n  4   5   6\n 10  11  19\n\njulia> baseInt(m)\n3×3 Matrix{Int64}:\n 1  2   7\n 0  3   7\n 0  0  15\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.complementInt","page":"Home","title":"MatInt.complementInt","text":"complementInt(full::Matrix{<:Integer}, sub::Matrix{<:Integer})\n\ncomplementInt(sub::Matrix{<:Integer})\n\nLet M be the integral row space of full and let S be the integral row space   of  sub,  which  should  be  a  subspace  of  M.  The  function complementInt computes a free basis for M that extends S, that is, if the dimension of S is n it determines a basis B={b₁,…,bₘ} for M, as well as n integers x₁,…,xₙ such that the n vectors sᵢ:=xᵢ⋅bᵢ form a basis  for S. If only one argument is  given, full is assumed to be the identity matrix of size size(sub,2).\n\nThe  function  complementInt  returns  a  named  tuple with the following components:\n\ncomplement a matrix whose rows are bₙ₊₁,…,bₘ.\nsub a matrix whose rows are the sᵢ (a basis for S).\nmoduli the factors xᵢ.\n\njulia> n=[1 2 3;4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> complementInt(n)\n(complement = [0 0 1], sub = [1 2 3; 0 3 6], moduli = [1, 3])\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.lnullspaceInt","page":"Home","title":"MatInt.lnullspaceInt","text":"lnullspaceInt(m::Matrix{<:Integer})\n\nreturns a matrix whose rows form a basis of the integral lnullspace of m, that  is  of  elements  of  the  left  nullspace  of m that have integral entries.\n\njulia> m=[1 2 7;4 5 6;7 8 9;10 11 19;5 7 12]\n5×3 Matrix{Int64}:\n  1   2   7\n  4   5   6\n  7   8   9\n 10  11  19\n  5   7  12\n\njulia> MatInt.lnullspaceInt(m)\n2×5 Matrix{Int64}:\n 1  18   -9  2  -6\n 0  24  -13  3  -7\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.intersect_rowspaceInt","page":"Home","title":"MatInt.intersect_rowspaceInt","text":"intersect_rowspaceInt(m::Matrix{<:Integer}, n::Matrix{<:Integer})\n\nreturns  a  matrix  whose  rows  forms  a  basis of the intersection of the integral row spaces of m and n.\n\njulia> mat=[1 2 7;4 5 6;10 11 19]; nat=[5 7 2;4 2 5;7 1 4]\n3×3 Matrix{Int64}:\n 5  7  2\n 4  2  5\n 7  1  4\n\njulia> intersect_rowspaceInt(mat,nat)\n3×3 Matrix{Int64}:\n 1  5  509\n 0  6  869\n 0  0  960\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.solutionmatInt","page":"Home","title":"MatInt.solutionmatInt","text":"solutionmatInt(mat::Matrix{<:Integer}, v::Vector{<:Integer})\n\nreturns  an  integral  vector  x  that  is  a  solution  of  the equation mat'*x=v. It returns nothing if no such vector exists.\n\njulia> mat=[1 2 7;4 5 6;7 8 9;10 11 19;5 7 12]\n5×3 Matrix{Int64}:\n  1   2   7\n  4   5   6\n  7   8   9\n 10  11  19\n  5   7  12\n\njulia> solutionmatInt(mat,[95,115,182])\n5-element Vector{Int64}:\n  2285\n -5854\n  4888\n -1299\n     0\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.solutionnullspaceInt","page":"Home","title":"MatInt.solutionnullspaceInt","text":"solutionnullspaceInt(mat, v)\n\nreturns   a  Tuple  of   length  two,  with   first  entry  the  result  of solutionmatInt(mat,v), and last entry the result of lnullspaceInt(mat). The calculation is performed faster than if two separate calls are used.\n\njulia> mat=[1 2 7;4 5 6;7 8 9;10 11 19;5 7 12]\njulia> MatInt.solutionnullspaceInt(mat,[95,115,182])\n([2285, -5854, 4888, -1299, 0], [1 18 … 2 -6; 0 24 … 3 -7])\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.prime_part","page":"Home","title":"MatInt.prime_part","text":"prime_part(N,a)  largest factor of N prime to a\n\n\n\n\n\n","category":"function"},{"location":"#MatInt.NormalFormIntMat","page":"Home","title":"MatInt.NormalFormIntMat","text":"NormalFormIntMat(A;options)\n\ngeneral operation for computation of various Normal Forms.\n\nOptions:\n\ntriang=true: Triangular form / Smith Normal form.\nreddiag=true: Reduce off diagonal entries.\nrowtrans=true: Row transformations.\ncoltrans=true: Col transformations.\n\nCompute  a Triangular,  Hermite or  Smith form  of the  nxm integer input matrix  A.  Optionally,  compute  nxn  /  mxm  unimodular  transforming matrices Q, P which satisfy Q C A==H or Q C A B P==S.\n\nTriangular / Hermite :\n\nLet I be the min(r+1,n)xmin(r+1,n) identity matrix with r=rank(A). Then Q and C can be written using a block decomposition as\n\nbeginpmatrixQ1Q2Iendpmatrix   beginpmatrixC1C2IendpmatrixA==H\n\nSmith :\n\nbeginpmatrixQ1Q2Iendpmatrix   beginpmatrixC1C2IendpmatrixA   beginpmatrixB1B2Iendpmatrix   beginpmatrixP1P2*Iendpmatrix==S\n\n* - possible non-zero entry in upper right corner...\n\nThe routines used are based on work by Arne Storjohann and were implemented in GAP4 by him and R.Wainwright.\n\nReturns a Dict with entry :normal containing the computed normal form and optional  entries :rowtrans and/or :coltrans  which hold the respective transformation matrix. Also in the dict are entries holding the sign of the determinant if A is square, :signdet, and the rank of the matrix, :rank.\n\njulia> m=[1 15 28;4 5 6;7 8 9]\n3×3 Matrix{Int64}:\n 1  15  28\n 4   5   6\n 7   8   9\n\njulia> MatInt.NormalFormIntMat(m,reddiag=true,rowtrans=true)\nDict{Symbol, Any} with 6 entries:\n  :rowQ     => [-2 62 -35; 1 -30 17; -3 97 -55]\n  :normal   => [1 0 1; 0 1 1; 0 0 3]\n  :rowC     => [1 0 0; 0 1 0; 0 0 1]\n  :rank     => 3\n  :signdet  => 1\n  :rowtrans => [-2 62 -35; 1 -30 17; -3 97 -55]\n\njulia> r=MatInt.NormalFormIntMat(m,triang=true,rowtrans=true,coltrans=true)\nDict{Symbol, Any} with 9 entries:\n  :rowQ     => [-2 62 -35; 1 -30 17; -3 97 -55]\n  :normal   => [1 0 0; 0 1 0; 0 0 3]\n  :colQ     => [1 0 -1; 0 1 -1; 0 0 1]\n  :coltrans => [1 0 -1; 0 1 -1; 0 0 1]\n  :rowC     => [1 0 0; 0 1 0; 0 0 1]\n  :rank     => 3\n  :signdet  => 1\n  :rowtrans => [-2 62 -35; 1 -30 17; -3 97 -55]\n  :colC     => [1 0 0; 0 1 0; 0 0 1]\n\njulia> r[:rowtrans]*m*r[:coltrans]\n3×3 Matrix{Int64}:\n 1  0  0\n 0  1  0\n 0  0  3\n\n\n\n\n\n","category":"function"}]
}
